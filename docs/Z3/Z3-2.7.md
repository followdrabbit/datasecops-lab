# Z3-2.7 — Data Products & Access Patterns

**onde o dado curado vira serviço oficial — e todo o resto passa a ser “shadow IT”**

Até aqui, a Z3 garantiu que seus dados e features estão limpos, versionados, governados e seguros.
O próximo passo é evitar que cada time consuma isso “no fio descascado” e invente o próprio jeito de acessar.

É aí que entram os **Data Products & Access Patterns**:

Princípio central:

> **Ninguém mais deveria conectar direto em Raw ou sair montando SQL aleatório em cima da Curated.
> O consumo oficial acontece via data products bem definidos, versionados, documentados e protegidos.**

Em outras palavras: você transforma dados e features em *produtos de dados* com contratos claros, e define rotas oficiais de acesso. Isso é tanto arquitetura de dados quanto controle de segurança.

---

## 1) O que é um Data Product na Z3

Um **Data Product** é uma “API de dados” com contrato estável, dono e propósito claro.

Cada Data Product é construído **em cima da Curated Zone e/ou Feature Store**, nunca diretamente sobre Z2, e oferece uma visão pensada para consumo:

Exemplos no contexto bancário:

* `dp_risco_score_cliente_v1`

  * Campos: `customer_id`, `score_risco`, `faixa_risco`, `data_referencia`.
  * Uso: motores de crédito (Z7), analytics de risco.
* `dp_fraude_transacao_online_v1`

  * Eventos de transação com enriquecimentos de fraude (features agregadas).
* `dp_insights_cliente_360_v2`

  * Visão consolidada para times de CX / CRM (já com PII mascarada).

**Cada Data Product deve responder claramente:**

* O que entrega?
* Para quem existe (quem consome)?
* Com que frequência é atualizado?
* Quais garantias de qualidade e latência oferece?
* Quais dados sensíveis contém (se contiver) e como são protegidos?

Se não tem essas respostas → não é Data Product, é só uma tabela qualquer.

---

## 2) Tipos de Data Products (Curated & Features)

Na Z3, os principais tipos:

1. **Views/Tabelas Curadas de Alto Nível**

   * Ex.: `curated.risco_transacoes_v2_view`.
   * São “faces bonitas” sobre tabelas curadas (Z3-2.1).
   * Escondem complexidade de joins, filtros, flags.

2. **Feature Products**

   * Ex.: `feature.risco_cliente_v1`, `feature.fraude_dispositivo_v2`.
   * Derivados da **Feature Store (Z3-2.6)**.
   * Usados por modelos em Z4/Z6.

3. **APIs Internas de Dados**

   * Ex.: `/api/data/risk/score-cliente/v1?customer_id=...`
   * Implementadas via FastAPI/GraphQL/gRPC.
   * Expõem exatamente o necessário, com controle fino de acesso.

4. **Streams Curados**

   * Tópicos Kafka/Kinesis “prontos pra consumo”:

     * `topic.risco_tx_scored`,
     * `topic.fraude_alerta`.
   * Já com schema fixo, PII tratada, DQ aplicada.

5. **Data Marts / Semantic Layers**

   * Camada para BI (Looker, Superset, PowerBI):

     * métricas definidas,
     * dimensões confiáveis,
     * sem cada analista reinventar `revenue` de um jeito.

---

## 3) Access Patterns Oficiais (como se consome Z3 sem fazer besteira)

Definir **formas suportadas** de acesso é tão importante quanto criar os dados.

### 3.1 Acesso por Views & Tabelas Curadas

* Analistas e relatórios:

  * acessam **views documentadas**,
  * nunca tabelas internas de staging/transform.
* Vantagens:

  * isolamento: você pode mudar o físico sem quebrar o contrato lógico,
  * aplicar **Row-Level / Column-Level Security** nas views,
  * mascaramento centralizado em uma camada.

### 3.2 Acesso via APIs de Dados

* Para sistemas Z7 (core, canais, apps):

  * usar **APIs internas** ou o **Inference/Data Gateway**,
  * nunca conexão direta ao banco de Curated/Feature Store.
* Controles na borda da API:

  * **AuthN/AuthZ via IdP (Z8)**,
  * **mTLS**, **Rate Limiting**, **WAF**,
  * **auditoria fine-grained** (quem pediu qual dado de quem).

### 3.3 Acesso à Feature Store

* Serviços de inferência em Z6:

  * consomem features via **SDK/API oficial** da Feature Store.
* Nada de:

  * reimplementar transformação em cada microserviço,
  * ler direto da tabela Curated sem passar pela lógica de features.

### 3.4 Acesso para Data Science & Exploração

* Times de DS:

  * usam ambientes controlados (Z4 — Workbench) conectados à Z3,
  * acessam:

    * datasets Curated,
    * Feature Store offline,
    * nunca Raw sem justificativa e sem log.
* Controle:

  * perfis de acesso (RBAC/ABAC),
  * notebooks autenticados via IdP,
  * logs de queries (Z9),
  * PII mascarada por padrão.

---

## 4) Segurança & Governança Embutidas no Consumo

**Data Product = contrato + política de acesso**. Alguns padrões importantes:

### 4.1 Least Privilege por Data Product

* Cada API/view/feature group:

  * tem sua própria **policy**.
* Exemplo:

  * `dp_risco_score_cliente_v1`:

    * acessível só para:

      * `svc-core-credit`, `svc-app-cartao`, `role:risk_analyst`.
  * `dp_fraude_transacao_detalhe_v2` (com mais PII):

    * acessível só para `role:fraud_analyst`, com auditoria reforçada.

### 4.2 Coluna como fronteira de segurança

* Integração com Schema & Catalog (Z3-2.2, Z3-2.4):

  * campos `pii=true` ou `sensitivity=restricted`:

    * só disponíveis em endpoints/views específicas,
    * mascaramento automático para perfis comuns,
    * bloqueio em APIs públicas/internas não privilegiadas.

### 4.3 Auditoria no Ponto de Consumo

* Toda leitura de Data Product:

  * gera log com:

    * `who`, `what`, `when`, `where`, `why (client_id, purpose)`.
* Integração com Z9:

  * detectar:

    * consultas suspeitas,
    * varreduras massivas,
    * acessos fora de horário/perfil.

### 4.4 Proteção contra OWASP API & LLM Issues

Para Data Products entregues via APIs/LLM:

* **OWASP API Security**:

  * A01 (Broken Object Level Auth) → checar `resource_id` com dono/role,
  * A05 (Broken AuthZ) → usar ABAC por dataset/feature,
  * A10 (Server-Side Request Forgery / Injections) → proteger endpoints de dados.
* **OWASP LLM / GenAI**:

  * Data Products usados em RAG:

    * passam por filtros de conteúdo (Z6 LLM Gateway),
    * evitam expor PII/segredos em respostas de LLM.

---

## 5) Implementação no MLOps Security Lab (para mostrar na prática)

Você pode montar uma versão enxuta, mas fiel ao conceito:

1. **Definir 2–3 Data Products de exemplo**

   * `dp_risco_score_cliente_v1`
   * `dp_fraude_transacao_online_v1`
   * `dp_analytics_vendas_agrupado_v1` (apenas agregados, sem PII).

2. **Criar Views / Tabelas dedicadas**

   * Exemplo:

     ```sql
     CREATE VIEW dp_risco_score_cliente_v1 AS
     SELECT
       c.customer_id,
       f.score_risco,
       f.faixa_risco,
       f.referencia_data,
       c.segmento
     FROM feature_risco_cliente_v1 f
     JOIN curated_clientes_v3 c
       ON f.customer_id = c.customer_id;
     ```
   * Aplicar:

     * Column-level security para esconder campos sensíveis conforme role.

3. **Subir uma API de Dados**

   * Ex.: `fastapi` em Z6:

     * Endpoint `/risk/score/{customer_id}`:

       * lê `dp_risco_score_cliente_v1`,
       * exige JWT com `role:core_credit` + mTLS,
       * loga todas as chamadas.

4. **Policies & Logs**

   * No MinIO/DB:

     * policy só permitindo `SELECT` nas views `dp_*` para serviços/roles autorizados.
   * No SIEM (Z9):

     * alertas para:

       * SELECT massivos em `dp_*` sensíveis,
       * acessos por roles não esperadas.

5. **Documentar no Catálogo (Z3-2.4)**

   * Cada `dp_*` com:

     * descrição,
     * owner,
     * SLA,
     * sensibilidade,
     * dependências (Curated/Features),
     * regras de acesso.

---

## 6) Anti-patterns (que você pode citar como “não fazemos”)

* BI apontando direto para `raw.*` ou `curated.*` sem mediação.
* Aplicação de internet com `SELECT * FROM curated_clientes_v3`.
* Dashboard com PII sem mascaramento por padrão.
* Data Product “v2” que muda schema sem avisar ninguém.
* Time de ML criando features lendo CSV local sem passar por Z3/Feature Store.

Mensagem forte:

> **Se um consumidor está lendo dados fora dos Data Products/View/Feature Store oficiais, isso é um *shadow data pipeline* e deve ser tratado como risco de segurança + governança.**

---

## 7) Alinhamento com Frameworks & Riscos (Z3 Seção 3)

**Frameworks**

* **OWASP API Security Top 10**

  * Controles de AuthZ, validação, rate limiting nos data services.
* **OWASP ML / LLM Top 10**

  * Reduz risco de injection/exfiltração via prompts ou features desgovernadas.
* **NIST SP 800-53**

  * AC-2/3/4/6 (controle de acesso),
  * AU-2/6 (auditoria de acesso a dados),
  * SC-7/SC-8 (proteção de interfaces).
* **CSA CCM / AICM**

  * AIS, DSI, IAM, LOG, SEF — “data as a service” seguro e governado.
* **LGPD / GDPR**

  * Minimização, necessidade, controle de acesso, accountability via logs.

**Riscos Z3 mitigados diretamente:**

* 3.2 — Vazamento de PII: porque o acesso passa por views/APIs que mascaram e restringem.
* 3.4 — Bypass da Z3/Z2: porque quem tenta fora dos data products deixa rastro e pode ser bloqueado.
* 3.5 — Falta de transparência: contratos, docs e lineage por data product.
* 3.6 — Supply chain de features: apenas consumindo features/documentos oficiais, com owner e versionamento.
