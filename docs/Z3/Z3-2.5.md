# Z3-2.5 — Classificação, Pseudonimização & PII Handling

**(onde privacidade deixa de ser banner e vira arquitetura)**

Na Z3 a gente para de tratar “segurança” e “LGPD” como slide de governança e passa a embutir isso no **modelo de dados, nos pipelines e nos contratos de acesso**.

Princípio central:

> **Tudo que entra em Z3 é classificado, minimizado e, quando necessário, pseudonimizado/mascarado.
> O dado sensível não “some”, ele é controlado, rastreado e usado só quando faz sentido.**

---

## 1) Objetivo

A camada de **Classificação, Pseudonimização & PII Handling** serve para:

* Garantir **compliance** com LGPD/GDPR, normas BACEN e boas práticas de privacidade e segurança.
* Reduzir a superfície de ataque: menos dados sensíveis expostos, menor impacto em caso de incidente.
* Proteger os modelos de:

  * vazamento de PII,
  * uso indevido de atributos sensíveis,
  * viés e discriminação não intencional.
* Transformar regras de privacidade em **controles técnicos verificáveis**, não só políticas no papel.

---

## 2) Classificação de Dados (Data Classification)

Antes de mascarar, encriptar ou limitar acesso, você precisa **saber o que está protegendo**.

### 2.1 Níveis de classificação (exemplo para o Lab / contexto bancário)

Definir poucos níveis, claros e aplicáveis:

1. **Pública**

   * Informação aberta (ex.: taxas de juros públicas, materiais de marketing).
2. **Interna**

   * Dados de operação interna sem PII forte (ex.: métricas agregadas, catálogos).
3. **Confidencial**

   * Dados de negócio sensíveis, porém não diretamente identificadores (ex.: limites de crédito agregados, regras internas).
4. **Restrita / PII / Sensível**

   * Dados pessoais identificáveis (nome, CPF, RG, endereço, e-mail, telefone),
   * Dados financeiros, biometria, geolocalização, dados de saúde, credenciais, segredos.

Cada **coluna** em Z3 deve ter um rótulo de classificação, registrado no **Schema Registry (Z3-2.2)** e exposto no **Data Catalog (Z3-2.4)**.

### 2.2 Como classificar (operacional)

* Combinar:

  * **Regras automáticas**:

    * regex para CPFs, CNPJs, cartões, e-mails,
    * listas de palavras-chave (ex.: “cpf”, “cnpj”, “telefone_cliente”).
  * **Curadoria manual**:

    * confirmação por data stewards/segurança,
    * revisão em PR no schema.
* Classificação vira parte do schema:

```yaml
columns:
  - name: cpf_hash
    type: string
    pii: true
    sensitivity: restricted
    transformation: tokenized
  - name: valor_compra
    type: decimal(18,2)
    pii: false
    sensitivity: confidential
```

---

## 3) Pseudonimização, Tokenização, Criptografia & Mascaramento

É importante separar os conceitos (isso rende pontos na entrevista):

### 3.1 Pseudonimização

* Substituir o identificador direto por um **identificador alternativo**, mantendo a capacidade de correlação controlada.
* Exemplo:

  * `cpf` → `cpf_token` (mesmo cliente, mesmo token).
* **Reversível ou não**, dependendo da técnica:

  * se reversível, chave guardada em **Vault/KMS**.
  * se irreversível (hash com salt), serve só para linkagem, não para “desanonimizar”.

Uso na Z3:

* Curated Zone guarda:

  * `cpf_token` (determinístico, ex. HMAC-SHA256 com chave no Vault),
  * e, se necessário, a tabela de referência `pii.cpf_map` em zona **Z2/Z8 altamente restrita**.
* Consumidores comuns:

  * enxergam só o token.

### 3.2 Tokenização

* Forma específica de pseudonimização.
* Gera um token que substitui o valor sensível.
* Pode ser:

  * **Determinístico**: mesmo input → mesmo token (permite join).
  * **Format-preserving**: parece um CPF, mas não é real.
* Implementação segura:

  * serviço de **Tokenization Service** interno,
  * com chaves em Vault/KMS,
  * acesso via API autenticada/mTLS.

### 3.3 Criptografia em nível de campo

* Quando você **precisa recuperar o valor original** (ex.: time de fraude, BackOffice).
* Ex.:

  * `numero_cartao` criptografado com chave no Vault (Transit),
  * só serviços com permissão `decrypt` conseguem ver o valor real.
* Importante:

  * combina com tokenização:

    * `cartao_token` para uso geral,
    * `cartao_cipher` para recuperação controlada.

Alinhado com **NIST SP 800-53 SC-12/SC-13/SC-28** e **CSA CCM DSI & CRY**.

### 3.4 Mascaramento

* Esconde parcialmente o dado na **camada de apresentação**.
* Exemplo:

  * mostrar `***.***.***-123` em dashboards,
  * `****1234` para cartão.
* Implementado via:

  * **views SQL**, UDFs,
  * lógica na API/BI,
  * controlado por **role/atributos (ABAC)**.

---

## 4) Minimização & Purpose Limitation (uso legítimo)

Não basta proteger: tem que **não coletar / não expor o que não precisa**.

Regras práticas (boas pra entrevista):

1. **Collect minimal**:

   * não trazer para Z3 PII que não será usada.
2. **Separate stores**:

   * manter PII em tabelas/pastas separadas (`pii/`, `restricted/`),
   * e dados analíticos/ML com tokens ou agregados.
3. **Profiles de acesso por uso**:

   * `analyst` → só dados anonimizados/pseudonimizados,
   * `risk_operations` → superset controlado, quando há base legal.
4. **Propósito explícito nos metadados**:

   * dataset/feature com campo `purpose`:

     * ex.: `credit_risk_scoring`, `fraud_detection`, `regulatory_report`.
   * usado para verificar se o uso do dado é compatível com a finalidade declarada.

Alinhado com **LGPD (finalidade, minimização, necessidade)** e **GDPR (data minimisation, purpose limitation)**.
Reflete princípios de **NIST Privacy Framework** e **CSA CCM / AICM de privacidade**.

---

## 5) Controles Técnicos na Z3 (como isso fica real)

### 5.1 Integração com Vault / KMS (Z8)

* Chaves de tokenização/criptografia **não** ficam no código.
* Uso de:

  * **Vault Transit** para HMAC/Encrypt/Decrypt,
  * policies por serviço:

    * `svc-curate-clientes` pode chamar `transit/encrypt/cpf`,
    * `svc-backoffice` pode `decrypt` em contexto controlado,
    * `svc-ml-featurestore` só lê `*_token`, nunca `*_raw`.

### 5.2 Pipelines de Curadoria aplicando privacy-by-design

No fluxo Z2 → Z3 (Z3-2.1 + Z3-2.3):

1. Ler Raw com PII (acesso controlado).
2. Aplicar:

   * tokenização/pseudonimização,
   * mascaramento,
   * remoção de colunas desnecessárias.
3. Gravar em Curated:

   * com PII minimizada,
   * colunas sensíveis etiquetadas,
   * PII “full” só em áreas `restricted` com IAM estrito.

### 5.3 Data Catalog & Policies automáticas

* Catálogo (Z3-2.4) sabe:

  * quais colunas são PII,
  * quais datasets são `restricted`.
* Engine de políticas (Z8) lê essa metadata:

  * gera automaticamente policies:

    * “bloquear SELECT em `*_cpf`, `*_email` para roles sem permissão”.
  * pode integrar com Row-Level / Column-Level Security em DW/engines.

### 5.4 Data Loss Prevention (DLP) & Monitoramento (Z8/Z9)

* Regras de DLP:

  * detectar PII em campos errados (ex.: CPF em `descricao_obs`),
  * bloquear exportações suspeitas (CSV gigante com PII).
* Logs de acesso a colunas sensíveis:

  * enviados para SIEM (Z9),
  * correlação com identidades (Z8),
  * alertas em caso de:

    * downloads massivos,
    * acessos fora do perfil,
    * consultas estranhas (ex.: `SELECT * FROM pii.cpf_map`).

---

## 6) Riscos mitigados (ligando com Z3 — Seção 3)

Esta camada endereça diretamente:

1. **3.2 — Vazamento de PII e dados sensíveis**

   * Classificação + tokenização + criptografia + RBAC/ABAC + logs.
2. **3.3 — Target/Attribute Leakage**

   * Controle sobre quais atributos sensíveis entram nas features/modelos.
3. **Uso indevido de dados entre domínios**

   * Purpose limitation + policies guiadas pelo catálogo.
4. **Compliance & Auditoria**

   * Evidência técnica de que PII é tratada com:

     * minimização,
     * segregação,
     * controles de acesso,
     * logging.

---

## 7) Implementação no MLOps Security Lab (concreto para você mostrar)

Você pode montar algo assim no seu repositório/VPS:

1. **Configurar classificações no Schema Registry**

   * Adicionar campos `sensitivity` e `pii` às definições de schema.
2. **Criar um `privacy-policy.yaml`**

   * Definindo:

     * quais tipos de PII existem,
     * onde podem aparecer,
     * qual técnica aplicar (token, crypto, mask).
3. **Implementar um `privacy-transform` nos DAGs**

   * Ex. em Python:

     * detectar colunas PII pelo schema,
     * chamar Vault Transit para tokenizar,
     * salvar `*_token` em vez de `*_raw`.
4. **Expor no README / Documentação**

   * Diagramar:

     * Z2 (dados brutos com PII) → Z3 (dados curados + tokens),
     * Tabela `pii_identity_map` isolada, usada só por serviços autorizados.
5. **Simular DLP**

   * Script que scaneia tabelas Curated:

     * busca regex de CPF/E-mail em colunas não marcadas como PII,
     * gera alerta se encontrar.

---

## 8) Frase pronta pra entrevista

Se te perguntarem “como você lida com PII e privacidade na sua arquitetura de MLOps?”:

> “Na camada Z3 eu aplico classificação por coluna, tokenização/pseudonimização via Vault/KMS, mascaramento por função e minimização por design.
> Features e datasets curados carregam metadados de sensibilidade e finalidade, integrados ao catálogo e ao IAM/ABAC. Assim, um modelo nunca treina sem sabermos *que dados pessoais está usando*, por que eles estão ali, quem pode acessá-los e como tudo isso é auditado ponta a ponta.”
