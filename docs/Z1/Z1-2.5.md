# 2.5 Anti-malware, CDR & Sandbox

Depois de:

1. passar pelo **WAF** (ataques genéricos),
2. ser **autenticado/autorizado** (sabemos quem é),
3. passar na **Content Validation** (tipo/tamanho/schema ok),

se a requisição envolve **arquivos** (PDF, imagem, CSV, ZIP, etc.), entra este bloco:

> **Antes de qualquer arquivo tocar no seu data lake ou pipeline de ML, trate como potencialmente malicioso.**

Esse componente é crítico porque:

* ingestão de documentos/arquivos é muito comum,
* libs de parsing são grandes e cheias de histórico de CVEs,
* ETL, workers e serviços internos normalmente não foram feitos pra enfrentar malware.

A Z1 resolve isso com camadas combináveis:

1. **Antivírus/Anti-malware com Multi-engine & Recursive Scan**
2. **CDR (Content Disarm & Reconstruction)**
3. (Opcional) **Sandbox/Detonação**

---

## 2.5.1 Escopo: o que passa por Anti-malware/CDR?

Nem tudo, senão você mata performance à toa.

**Passam por esse fluxo (obrigatório Anti-malware, preferencialmente com CDR quando aplicável):**

* Uploads de:

  * documentos (PDF, DOCX, XLSX, PPTX),
  * imagens (quando enviadas como evidência, anexos, comprovantes),
  * arquivos comprimidos (ZIP, RAR, etc.),
  * qualquer binário vindo de cliente, parceiro ou fonte externa.
* Arquivos oriundos de:

  * canais públicos,
  * parceiros,
  * automações internas com menor governança.

**Normalmente não passam diretamente por scan de arquivo binário:**

* JSON, CSV “simples” tratados como texto estruturado (mas ainda sujeitos à validação de conteúdo e qualidade).
* Dados produzidos por serviços internos confiáveis *dentro* do perímetro (aqui o foco passa a ser integridade/poisoning lógico, não malware).

> Mesmo assim, qualquer fluxo novo ou pouco confiável pode ser incluído na política de scan conforme risco.

---

## 2.5.2 Anti-malware (Multi-engine + Recursive Scan)

**Ideia:** tratar **todo arquivo** como potencialmente malicioso; **não** depender de um único motor nem apenas da “casca” (arquivo de topo). O objetivo é **reduzir falsos negativos**, **detectar armadilhas de empacotamento** e **bloquear** antes que qualquer coisa toque a Z2.

### Multi-engine

Executar a verificação com **mais de um mecanismo de detecção**, por exemplo:

* **Antivírus OSS** (ex.: ClamAV) para cobertura básica e automação simples.
* **Motor comercial/serviço dedicado** (quando disponível) para *heurística*, ML e *cloud intel*.
* **Regras internas** (ex.: **YARA**) para padrões específicos do negócio/campanhas ativas.

**Benefícios:**

* Se um *engine* falha, outro pode detectar (**reduz falsos negativos**).
* Combina assinaturas, heurísticas e detecção baseada em regras (**amplia a cobertura**).

### Recursive scan (análise recursiva com limites)

Inspecionar **também** o conteúdo **interno** de contêineres e arquivos compostos:

* **Descompactar**: ZIP/RAR/7z/TAR/ISO; inspecionar cada item.
* **Abrir compostos Office/PDF** (DOCX/XLSX/PPTX, PDF com objetos/JS).
* **Aplicar limites** para proteção operacional (*anti zip-bomb*):

  * **Profundidade máxima** de aninhamento (ex.: `max_depth = 3`).
  * **Tamanho total descompactado** (ex.: `max_unpacked = 200 MB`).
  * **Número máximo de arquivos** internos (ex.: `max_files = 1000`).
  * **Tempo máximo de varredura por arquivo** (ex.: `scan_timeout = 30s`).

> **Arquivos protegidos por senha** (ex.: `ZIP` com senha): **bloquear** por padrão ou enviar a **quarentena** para análise manual, conforme política.

### Salvaguardas operacionais

* **Isolamento de recursos**: *container* dedicado ao *scan* com **CPU/memória** limitados.
* **Armazenamento efêmero** para extrações temporárias.
* **Cotas/concurrency**: impedir que *uploads* massivos degradem a Z1.
* **Atualizações de assinaturas/regras**: *schedule* diário (ou mais) para AV/YARA.
* **Cache de hashes** (`SHA-256`) para **known-good/known-bad** (evita *re-scan* inútil).

### Comportamento esperado na Z1

Analisar o arquivo **e seus filhos internos** em busca de:

* **Assinaturas** conhecidas, **macros/scripts** maliciosos, *payloads ofuscados*, *droppers*, *webshells*.
* **Indicadores de exploração** em PDFs/Office (JS embutido, OLE/links ativos).

**Integração no fluxo (resposta)**: `clean` • `infected` • `suspicious` (ex.: heurística alta, arquivo truncado, proteção por senha).

### Política de decisão (mínimo recomendado)

* Se **qualquer** *engine/regra* retornar `infected` **ou** `suspicious`:

  * **Bloquear** imediatamente.
  * **Logar** origem, hash (`sha256`), endpoint, identidade e **motivo**.
  * Enviar para **quarentena/forense** (opcional).
  * **Nunca** permitir que siga para a **Z2**.
* Se **todos** retornarem `clean`:

  * Encaminhar para **CDR** (quando aplicável) e, depois, seguir o fluxo (ETL/MQ).

### Logging & auditoria (mínimo)

* `file_name`, `mime_detected`, `sha256`, `size_in/out`, `max_depth_hit?`, `unpacked_size`, `scan_time_ms`.
* `result_per_engine` (ex.: `{clamav: clean, vendorX: clean, yara: suspicious(rule_id=...)}`), `decision`.
* `source_identity` (cliente/parceiro), `route`, `correlation_id`.
* Retenção e **integridade** dos logs conforme Z9.

### Integrações & contratos

* **Antes** de Anti-malware: **Content Validation** (tipo/tamanho/schema) — impede lixo estrutural.
* **Depois** de Anti-malware: **CDR** (quando o objetivo é apenas *conteúdo* do documento).
* **Contratos**: *allowlist* de MIME por rota; **limites** por tipo de arquivo; **mensagens** de erro sem vazar detalhes sensíveis.

### Política como código (exemplo OPA/Rego)

```rego
package z1.malware.decision
default allow = false

allow {
  input.scan.overall == "clean"
  not input.scan.flags.password_protected
  input.scan.max_depth <= 3
  input.scan.unpacked_size_mb <= 200
}
```

### “No lab” (simulação prática)

* **`scan-service`** (ex.: FastAPI) chamando **ClamAV/clamd**; *stub* opcional para segundo *engine*.
* **Gateway**:

  1. valida tipo/tamanho/schema →
  2. chama `/scan` com *stream* do arquivo →
  3. decide:

     * `infected/suspicious` → **HTTP 4xx** + log; **não** persiste,
     * `clean` → segue para **CDR** (se houver) e **ETL/MQ**.
* **Mensagens didáticas**:

  * “**Arquivo nunca vai direto para o bucket**; **sempre** passa por *scan* dedicado.”
  * “**ZIP com senha** não é aceito sem *workflow* de exceção.”

### Riscos mitigados (referências)

* **Código malicioso** em documentos/arquivos (NIST **SI-3**).
* **Exploração** de *parsers* (OWASP **File Upload** Cheat Sheet).
* **Zip-bomb/DoS** via *upload* (OWASP **API4: Unrestricted Resource Consumption**).
* **Lateral movement** via ETL/workers (defesa em profundidade na borda).

> Mensagem didática: **“arquivo nunca vai direto pro bucket; sempre passa por scan dedicado.”**

---

## 2.5.3 CDR — Content Disarm & Reconstruction

CDR é o “modo paranóico inteligente”:

> Em vez de perguntar só “tem malware conhecido?”,
> pergunta “que partes deste arquivo podem ser perigosas?”
> e reconstrói uma **versão segura**.

Exemplos de atuação:

* Em documentos Office:

  * remove macros, OLE, links ativos, conteúdo dinâmico.
* Em PDFs:

  * remove JavaScript embutido,
  * remove formulários/ações automatizadas.
* Em imagens:

  * reprocessa o arquivo,
  * limpa metadata suspeita.

**Resultado:**
Você guarda/usa apenas uma cópia **sanitizada**, reduzindo muito a superfície de ataque.

**Quando faz sentido:**

* Upload de documentos por clientes (KYC, comprovantes, contratos).
* Troca de arquivos com terceiros.
* Cenários em que o conteúdo é de leitura/visualização, não execução.

**No lab:**

* Não precisa implementar CDR corporativo,
* mas pode:

  * restringir tipos aceitos,
  * normalizar arquivos,
  * documentar que em ambiente real:

    > “Aqui entraria o CDR para documentos de alto risco.”

---

## 2.5.4 Sandbox / Detonação (opcional, avançado)

Para contextos de risco muito alto:

> “Mesmo após scan e CDR, ainda quero observar o comportamento.”

Sandbox é:

* executar o arquivo em ambiente totalmente isolado,
* monitorar:

  * tentativas de conexão externa,
  * criação de arquivos/execução suspeita,
  * alterações estranhas no sistema.

Se o comportamento for malicioso → bloqueio definitivo, alerta, possível investigação.

**Por que é opcional no lab:**

* Alto custo operacional e técnico,
* mais comum em bancos/grandes empresas,
* mas importante citar como “próximo nível” para uploads críticos.

---

## 2.5.5 Integração no fluxo Z1 (onde entra Anti-malware/CDR)

Ordem lógica típica:

1. Requisição chega (com arquivos).
2. **WAF** filtra ataques genéricos.
3. **AuthN/AuthZ** garante identidade e escopo.
4. **Content Validation** confere:

   * tipo/MIME permitido,
   * tamanho máximo,
   * formato básico.
5. **Anti-malware (Multi-engine + Recursive Scan)**:

   * se `infected`/`suspicious`:

     * bloqueia + log + (opcional) quarentena.
   * se `clean`:

     * segue.
6. **CDR** (quando aplicável):

   * gera cópia sanitizada para uso interno.
7. Apenas então:

   * arquivos/dados seguem para **2.6 Higiene inicial (quando estruturado)**,
   * e para **2.7 ETL / MQ / Streaming (conectores oficiais)**,
   * que persistem em **Z2 — Raw Data Lake**.

**Importante:**

* Se o arquivo falhar em qualquer etapa:

  * ele **NÃO** deve chegar à Z2.
* Sempre registrar:

  * fonte,
  * decisão,
  * motivo do bloqueio,
  * hash ou ID do arquivo (especialmente se for para quarentena).

---

## 2.5.6 Riscos mitigados

Este bloco é a defesa direta contra:

* entrada de malware e payloads ativos na infraestrutura de dados,
* exploração de bibliotecas de parsing (PDF, Office, imagens, compactadores),
* uso da camada de ingestão como vetor para ataque interno ou lateral,
* ocultação de malware em arquivos aninhados/compactados.

Conecta-se com:

* **Defesa em profundidade**,
* **NIST SP 800-53 SI-3** (proteção contra código malicioso),
* boas práticas **OWASP** para upload seguro.

---

## 2.5.7 Implementação sugerida no Lab (prático e didático)

Para o **MLOps Security Lab**, você pode:

* Criar um serviço `scan-service` (FastAPI + ClamAV, por exemplo):

  * endpoint interno `/scan`,
  * recebe arquivo,
  * faz scan (e simula multi-engine se quiser),
  * responde `clean` ou `infected`.
* Ajustar o Ingestion Gateway para:

  * checar tipo/tamanho (Content Validation),
  * enviar o arquivo ao `scan-service`,
  * decidir:

    * se `infected` → 4xx + log, não salvar,
    * se `clean` → salvar em staging seguro / acionar ETL oficial.
* Documentar explicitamente no README/Z1:

> “Nenhum arquivo é persistido em Raw (Z2) sem passar por scan (multi-engine + recursive) e, quando aplicável, sanitização (CDR). Arquivo é dado hostil por padrão.”
