
# 2.3 Autenticação & Autorização (AuthN/AuthZ) na borda

Na Z1, **ninguém manda dado de graça**.

Tudo que sai da Z0 (cliente, parceiro, sistema interno, script, job) e tenta falar com o Ingestion Gateway precisa:

1. **Provar quem é** (Autenticação — AuthN),
2. **Provar o que pode fazer** (Autorização — AuthZ),

antes de chegar perto do data lake (Z2) ou dos serviços internos.

Isso vale tanto para:

* fontes externas (APIs públicas/partner),
* quanto para fontes internas (core, CRM, DW, jobs agendados).

---

## 2.3.1 Autenticação (AuthN) — “quem é você?”

**Objetivo:** ter certeza de qual sistema/usuário está fazendo a chamada.

Mecanismos típicos (todos aplicáveis na borda da Z1):

### 2.3.1.1. OIDC/OAuth2 (recomendado para o lab e mundo real)

* O chamador (cliente/app/sistema) obtém um **token** de um IdP (ex.: Keycloak).

* A requisição chega no gateway com algo como:

  ```http
  Authorization: Bearer eyJhbGciOi...
  ```

* O gateway:

  * valida a assinatura do token,
  * checa se está dentro do tempo,
  * verifica emissor e audiência.

* Resultado:

  * “Ok, essa requisição é do `client_id = parceiro-x`”
  * ou “é do `ingestor-airflow`”, etc.

**Ponto forte:** identidade padronizada, integrável com RBAC/ABAC, fácil de auditar.

---

### 2.3.1.2. API Keys gerenciadas

* Chaves longas, únicas por cliente/sistema.

* Passadas em header, ex.:

  ```http
  X-API-Key: 1f4fa3c2-...
  ```

* Validada pelo gateway numa store segura (Vault, DB protegido).

**Uso típico:**

* integração técnica simples (job batch, sistema legado),
* ambientes de lab/demonstração.

**Cuidados:**

* chave nunca hardcoded em código público,
* rotação periódica,
* revogação rápida.

---

### 2.3.1.3. mTLS (mutual TLS)

* Além de HTTPS normal, o cliente também apresenta um **certificado cliente**.
* O gateway verifica:

  * se o certificado é emitido por CA confiável,
  * se está dentro da lista de permitidos.

**Uso ideal:**

* integrações sensíveis entre sistemas internos,
* conexões de parceiros críticos,
* quando você quer autenticação forte “em nível de canal”.

---

**Resumo da AuthN na Z1:**

* Nada de “IP fixo = confiável”.
* Nada de “token hardcoded em código, espalhado”.
* Identidade sempre:

  * emitida por um IdP/autoridade confiável,
  * validada no gateway,
  * registrada em log.

---

## 2.3.2 Autorização (AuthZ) — “o que você pode fazer?”

Depois de saber “quem é”, vem a parte mais importante: **limitar o poder**.

Autorização na Z1 significa:

> Uma fonte autenticada **só** pode chamar os endpoints/tópicos/buckets que foram designados pra ela.

Exemplos:

* Parceiro antifraude:

  * pode chamar `POST /ingest/antifraude` com o token/par de chaves dele.
  * não pode mandar nada para `/ingest/openfinance` ou `/ingest/interno`.
* Sistema de core:

  * pode mandar eventos de transação para `/ingest/transacoes`.
  * não pode acessar endpoints de outro domínio.
* Job batch interno:

  * tem permissão apenas para `/ingest/logs-seguranca` ou leitura de fila X,
  * não tem direito de chamar endpoints de upload de documentos de clientes.

**Como implementar isso:**

1. **No Gateway / API Gateway**

   * Mapear regras:

     * “client_id X” → pode acessar `/ingest/parceiro-x/*`
     * “client_id Y” → `/ingest/core-transacoes`
   * Bloquear tudo o que não bate com as regras.

2. **Por claims do token (RBAC/ABAC)**

   * Token JWT com `roles`, `scope`, `tenant_id`.
   * Ex.: `scope: ingest:transacoes` → só endpoints de transações.
   * Gateway ou serviço verifica essas claims antes de aceitar.

3. **No backend/serviço de ingestão**

   * Mesmo depois do gateway, o serviço também checa:

     * “este token realmente tem permissão de escrever neste dataset?”

**Ideia-chave:**

* Autenticação sem autorização = “sei quem é você, mas deixo fazer qualquer coisa” → errado.
* Autorização fina na borda impede:

  * uso indevido de credenciais,
  * parceiro escrevendo no lugar errado,
  * impacto grande em caso de comprometimento.

---

## 2.3.3 Como isso aparece na prática do Lab

No **MLOps Security Lab**, a proposta é:

* Usar **Keycloak (ou outro IdP)** para emitir tokens OIDC/OAuth2.
* Usar **Vault** como store de segredos/credenciais de serviços.
* Configurar serviços internos para:

  * **não** ter usuário/senha fixos em código,
  * buscar tokens/segredos via Vault Agent ou mecanismo seguro.

Fluxos típicos:

1. **Serviço de ingestão interno / Airflow**:

   * Pega credencial via Vault.
   * Se autentica no gateway com API key/token.
   * Gateway sabe: “é o Airflow de ingestão oficial”.

2. **Simulação de parceiro externo**:

   * Usa um token/API key específica.
   * Só tem acesso a endpoints “/ingest/parceiro-x”.

3. **Nada de credencial hardcoded**

   * Se aparecer senha/token dentro de código do lab:

     * isso é apresentado como mau exemplo a ser corrigido.

---

## 2.3.4 Por que AuthN/AuthZ na borda é tão importante em Z1

Porque sem isso:

* qualquer script pode mandar dado,
* você não sabe de onde veio nada,
* não consegue auditar nem cortar uma fonte comprometida,
* abre porta pra:

  * data poisoning,
  * spam de ingestão,
  * abuso de API,
  * uso fora de escopo (LGPD/compliance).

Com AuthN/AuthZ forte:

* você trata cada fonte como um **sujeito identificado**:

  * com dono,
  * com responsabilidade,
  * com permissões específicas,
  * com logs completos.

Isso alinha com:

* **NIST (AC-*, IA-*)**: controle de acesso e identidade.
* **OWASP API Security**: Broken Authentication / Broken Access Control.
* **CSA CCM / AICM**: identidade, segredos, privilégios mínimos.
