# 2.8 Auditoria & Observabilidade

A Z1 não é só o portão de entrada.
Ela também é o lugar onde você cria a **memória confiável** de tudo que tentou entrar:

> Quem chamou, o que tentou mandar, o que foi aceito, o que foi bloqueado, e por quê.

Essa trilha é crítica para:

* segurança,
* investigação de incidentes,
* rastreabilidade de dados e modelos,
* compliance (LGPD, regulatório, auditoria interna),
* tunar regras (WAF, validação, limites).

E alimenta diretamente a **Z9 — Monitoring & Audit**.

Vamos quebrar isso.

---

## 2.8.1 O que a Z1 deve registrar (mínimo recomendável)

Para **cada requisição relevante** à Z1 (ingestão de dados, upload, evento), você quer ter algo nessa linha:

1. **Origem**

   * IP de origem (quando aplicável),
   * nome do host ou região (se disponível),
   * tipo: externo, parceiro, interno.

2. **Identidade utilizada**

   * `client_id` / `sub` do token OIDC/OAuth2,
   * ou chave/API key associada ao produtor,
   * ou CN do certificado (mTLS),
   * mapeado para uma **fonte Z0 oficial**:

     * ex.: `source_system = "core-transacoes"`,
     * `partner = "bureau-x"`.

3. **Endpoint e operação**

   * path chamado: `/ingest/transacoes`, `/ingest/docs`, etc.
   * método HTTP (`POST`, etc.).
   * versão (se houver `/v1`, `/v2`).

4. **Tipo e tamanho de payload**

   * `Content-Type` (ex.: `application/json`, `text/csv`, `application/pdf`).
   * `Content-Length` (tamanho do corpo).
   * para arquivos:

     * nome original (se aplicável),
     * tipo detectado,
     * hash (ex.: SHA-256) — importante para rastreio/quarentena.

5. **Resultado**

   * **Aceito**:

     * encaminhado para ETL/MQ/Z2.
   * **Rejeitado**:

     * por WAF,
     * por AuthN/AuthZ,
     * por validação de conteúdo,
     * por anti-malware,
     * por regras de qualidade.
   * Código de status (`2xx`, `4xx`, `5xx`).
   * **Motivo categorizado**, ex.:

     * `REJECTED_WAF_RULE`,
     * `INVALID_SCHEMA`,
     * `UNAUTHORIZED_CLIENT`,
     * `MALWARE_DETECTED`,
     * `RATE_LIMIT_EXCEEDED`.

6. **Correlação com camadas de segurança**

   * ID/label da regra de WAF disparada (se houver).
   * resultado do scan AV/CDR (clean/suspect/infected).
   * checagens de schema/qualidade (ex.: `10% records_invalid`).

7. **Metadados de correlação**

   * `X-Request-Id` / `X-Correlation-Id`.
   * timestamp preciso.
   * nó / pod / instância que atendeu.

Isso permite ir de:

> “Esse arquivo/modelo/dado suspeito apareceu aqui em Z4/Z5”

para:

> “Ele entrou pela requisição X, do cliente Y, via endpoint Z, no dia tal, e passou/falhou tais regras”.

---

## 2.8.2 O que **não** deve ir pro log

Tão importante quanto logar é **não vazar coisa errada** nos logs.

Evitar:

* corpo completo de payload com:

  * PII (CPF, cartão, endereço, etc.),
  * segredos (tokens, chaves),
  * conteúdo sensível (documentos).
* headers sensíveis:

  * `Authorization`,
  * cookies,
  * segredos em geral.

Boas práticas:

* logar **hash** ou **ID de referência** do arquivo/dado em vez do conteúdo bruto;
* mascarar dados sensíveis (ex.: `***` em partes críticas);
* logar amostras ou agregados se necessário para análise.

---

## 2.8.3 Destino: integração com Z9 — Monitoring & Audit

A Z1 não analisa tudo sozinha. Ela:

* **gera eventos ricos de log**, e
* envia para componentes de Z9, como:

  * stack de logs (ELK, Loki, etc.),
  * SIEM (Splunk, QRadar, etc.),
  * alertas e dashboards.

Isso permite:

1. **Monitorar saúde da ingestão**

   * taxa de sucesso/erro por fonte,
   * latência,
   * volume.

2. **Detectar abuso/ataques**

   * múltiplos `UNAUTHORIZED_CLIENT`,
   * explosão de `MALWARE_DETECTED`,
   * uso massivo de mesma chave de API,
   * padrões nos alerts do WAF.

3. **Apoiar auditorias**

   * provar que:

     * dados só entram por canais oficiais,
     * controles foram aplicados,
     * tentativas indevidas foram bloqueadas.

---

## 2.8.4 Exemplos práticos (como ficaria em log)

Um evento de log da Z1 poderia ter estrutura (conceitual):

```json
{
  "timestamp": "2025-11-09T10:32:15Z",
  "request_id": "abc123",
  "source_ip": "203.0.113.10",
  "source_system": "partner-abc",
  "client_id": "partner-abc-client",
  "endpoint": "/ingest/transacoes",
  "method": "POST",
  "content_type": "application/json",
  "content_length": 524288,
  "result": "ACCEPTED",
  "waf_rule": null,
  "av_status": "clean",
  "schema_validation": "passed",
  "quality_checks": {
    "invalid_records": 0,
    "status": "ok"
  }
}
```

Exemplo rejeitado:

```json
{
  "timestamp": "2025-11-09T10:35:02Z",
  "request_id": "def456",
  "source_ip": "198.51.100.23",
  "source_system": "unknown",
  "client_id": "unknown",
  "endpoint": "/ingest/docs",
  "method": "POST",
  "content_type": "application/x-msdownload",
  "content_length": 83456,
  "result": "REJECTED",
  "reason": "DISALLOWED_CONTENT_TYPE",
  "waf_rule": "OWASP_CRS_941100",
  "av_status": "not_scanned",
  "schema_validation": "not_applicable"
}
```

Esses dois exemplos já dão munição pro Z9 gerar:

* dashboards,
* alertas,
* relatórios de segurança.

---

## 2.8.5 Implementação prática no Lab

No **MLOps Security Lab**, você pode:

* Configurar:

  * Traefik/Nginx para gerar logs de acesso com `request_id`, path, status.
  * Serviços de ingestão para logar decisões de validação (schema, qualidade).
* Usar:

  * um stack simples (ex.: Loki + Grafana, ou ELK) para centralizar logs.
* Representar:

  * falhas de WAF,
  * rejeições por validação,
  * eventos de AV/CDR,
    como entradas lineares de log/documentos JSON.

O objetivo não é virar um SIEM completo, mas mostrar o fluxo:

> Z1 gera evidências estruturadas → Z9 consolida, alerta, audita.

---

## 2.8.6 Por que isso é crítico em segurança de IA/ML

Porque sem auditoria/observabilidade na Z1:

* você não sabe:

  * por onde dados ruins entraram,
  * se houve tentativa de envenenamento,
  * se controles foram aplicados direito,
* você não consegue:

  * explicar para auditor/regulador,
  * fazer *root cause analysis*,
  * melhorar as políticas.

Com boa auditoria na Z1, você consegue dizer:

> “Esse dataset usado para treinar o modelo X veio exclusivamente de fontes A e B, autenticadas, passando por validação, AV, WAF, e aqui estão os logs e hashes correspondentes.”

Isso é ouro em ambiente financeiro.
