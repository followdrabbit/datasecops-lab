
# 2.2 WAF (Web Application Firewall)

O **WAF (Web Application Firewall)** é o componente da Z1 responsável por inspecionar o tráfego HTTP/HTTPS na camada de aplicação (**camada 7**) antes dele chegar nos serviços internos.

Ele complementa o firewall de rede (que olha IP/porta/protocolo) olhando **o conteúdo das requisições** (URL, headers, parâmetros, corpo) para detectar e bloquear padrões maliciosos.

Em uma arquitetura segura — e no MLOps Security Lab — o WAF fica:

* na frente do **Reverse Proxy/API Gateway**, ou
* integrado a ele (ex.: módulo de WAF no próprio Nginx/Traefik ou serviço gerenciado do provedor cloud).

## 2.2.1 O que o WAF faz na prática

De forma bem direta, o WAF:

1. **Lê a requisição HTTP/HTTPS**

   * Método (`GET`, `POST`, etc.),
   * URL/path (`/ingest/...`),
   * parâmetros de query,
   * headers,
   * corpo (JSON, formulário, etc.).

2. **Compara com regras e assinaturas**

   * Regras estáticas (ex.: OWASP Core Rule Set),
   * Regras customizadas da sua organização.

3. **Decide**

   * Permitir,
   * Bloquear,
   * Logar como suspeito,
   * Desafiar (ex.: em alguns cenários web, com captcha, não é o foco aqui).

Ele é especialmente importante na Z1 porque **todos os dados passam aqui**. Se alguém tentar atacar, é por aqui que vem.

---

## 2.2.2 Tipos de ataques que o WAF ajuda a mitigar

No contexto da ingestão (APIs de dados), os alvos típicos são:

1. **Injection (SQL/NoSQL/Command Injection)**

   * Payloads tentando quebrar queries:

     * `"' OR '1'='1"`, `; DROP TABLE`, etc.
   * Comando em input que alguém joga esperando que seu backend concatene.
   * O WAF detecta padrões suspeitos em parâmetros e corpo e bloqueia.

2. **XSS (Cross-Site Scripting)**

   * Menos comum em ingestão, mas relevante em portals/UI:

     * `<script>alert(1)</script>`,
     * payloads HTML/JS.
   * WAF identifica e bloqueia antes de chegar na aplicação.

3. **Path Traversal**

   * Tentativas de acessar caminhos internos via URL:

     * `/../../etc/passwd`,
     * `/api/files?path=../../segredo`.
   * WAF barra esses padrões.

4. **RFI/LFI, SSRF e variações**

   * Tentativas de:

     * carregar arquivos locais,
     * forçar o servidor a chamar URLs internas.
   * Mesmo em APIs, isso aparece em parâmetros maliciosos.

5. **Payloads anômalos / binários onde não deveria**

   * Ex: corpo gigante, caracteres estranhos, sequência hex suspeita.
   * WAF pode bloquear baseado em tamanho, tipo, padrão.

6. **Ataques conhecidos (assinaturas)**

   * Regras prontas (tipo OWASP CRS) detectam:

     * scanners automatizados,
     * ferramentas de exploração padrão,
     * payloads que já são “famosos”.

**Importante:**
O WAF **não substitui** validação no código ou no gateway — ele é mais uma camada. Defesa em profundidade.

---

## 2.2.3 Como o WAF se encaixa na Z1 (arquitetura)

No fluxo da Z1:

1. Requisição chega na porta pública.
2. **Passa pelo WAF**:

   * se bater em regra bloqueante → request negado (4xx/5xx customizado) + log.
3. Se passar:

   * segue para o **Reverse Proxy/API Gateway**,
   * aplica AuthN/AuthZ,
   * valida headers, método, path, tamanho, etc.
4. Só então chega no serviço de ingestão/ETL.

Isso garante que:

* endpoints internos não vejam diretamente payload bruto malicioso;
* qualquer tentativa de exploração conhecida morra na borda;
* você tenha **logs centralizados de ataques** (ótimo para Z9).

---

## 2.2.4 Como usar WAF no Lab (sem complicar demais)

No **MLOps Security Lab**, a ideia não é montar um WAF corporativo completo, mas sim:

* Mostrar o conceito com:

  * Nginx com ModSecurity + OWASP CRS (se quiser avançar),
  * ou regras simples no Traefik/Nginx (tamanho máximo, bloqueios de certos padrões),
* Reforçar visualmente nos docs que:

  * nenhum endpoint de ingestão é “cru”,
  * tudo passa por uma camada que pode bloquear payload suspeito.

Exemplos práticos de coisas que você pode simular:

* Bloquear requests com:

  * `Content-Length` acima de X.
  * certos padrões em query/body (ex.: `DROP TABLE`, `<script>`).
* Logar tentativas para educar o leitor:

  * “olha, isso é o tipo de coisa que um WAF pegaria”.

---

## 2.2.5 Boas práticas de configuração (conceituais)

Mesmo em ambiente de lab, vale entender o “como pensar”:

* Começar em modo **detecção (monitor)**:

  * ver quais regras disparam,
  * ajustar para reduzir falso positivo.
* Depois habilitar **bloqueio** gradual.
* Criar regras específicas para:

  * paths de ingestão (`/ingest/...`),
  * tamanhos máximos,
  * tipos de conteúdo esperados.
* Integrar logs do WAF com:

  * Z9 (monitoramento),
  * análise de tentativa de ataque.

---

## 2.2.6 Relação com frameworks

* **OWASP Top 10 & API Security**:

  * WAF ajuda a mitigar diversos vetores (injeção, XSS, etc.).
* **NIST SP 800-53**:

  * Apoia controles de proteção de fronteira (SC-7), detecção de ataques, etc.
* **CSA CCM / AICM**:

  * Se encaixa em controles de interface segura, proteção de aplicações e monitoramento.
