# 2.1 Reverse Proxy / API Gateway (Ingestion Gateway)

O Reverse Proxy/API Gateway é o **ponto central da Z1**. Ele fica na frente dos serviços internos e faz quatro coisas essenciais:

1. **Exposição controlada**
2. **Segurança de transporte (TLS)**
3. **Roteamento seguro (paths, hosts, portas)**
4. **Aplicação de políticas (método, headers, limites, autenticação)**

---

## 2.1.1 Único endpoint público / de borda

Em um desenho seguro (e no Lab):

* Apenas o **gateway** (Traefik, Nginx, HAProxy, Envoy, Kong, API Gateway gerenciado etc.) fica exposto na porta 80/443 ou na frente de um load balancer.
* Todos os serviços de ingestão reais:

  * rodam em rede interna,
  * não têm IP público,
  * só recebem tráfego vindo do gateway.

Isso garante:

* superfície reduzida,
* inspeção e auditoria centralizadas,
* facilidade para aplicar WAF, rate limiting e autenticação.

No lab:

* Traefik/Nginx fazem esse papel.
* Em produção:

  * você poderia usar ALB/API Gateway (AWS), APIM (Azure), API Gateway (GCP), F5, Kong, Apigee, NGINX Plus etc., desde que cumpram a mesma função.

---

## 2.1.2 Terminar TLS (HTTPS)

O gateway:

* recebe conexões HTTPS dos produtores de dados,
* faz a terminação TLS (gerencia certificados),
* pode recriptografar o tráfego para trás (mTLS interno) ou falar HTTP apenas dentro da rede interna (no lab, por simplicidade).

Por quê?

* protege dados em trânsito,
* evita que cada serviço interno tenha que expor certificado público,
* centraliza a política criptográfica.

>Nota sobre a terminação TLS:
> A conexão criptografada do cliente vai até o gateway, e é lá que acontece a descriptografia (handshake TLS + validação de certificado). A partir desse ponto, o gateway já enxerga o tráfego em claro (dentro do servidor) para poder aplicar regras de segurança, roteamento e validação.

---

## 2.1.3 Regras de path (path-based routing) — o que é e para que serve

“Regras de path” = **rotear requisições com base na URL** e restringir quais caminhos existem.

Exemplos simples:

* `POST /ingest/transacoes` → serviço `ingest-transacoes`
* `POST /ingest/documentos` → serviço `ingest-docs`
* `POST /ingest/eventos` → serviço `ingest-eventos`

O que isso traz de segurança e organização:

1. **Contratos claros**

   * Cada tipo de dado tem um endpoint específico.
   * Fica óbvio “quem pode mandar o quê e para onde”.
2. **Menos superfície**

   * Em vez de expor o serviço inteiro, você expõe só alguns paths permitidos.
   * Nada de `/admin`, `/debug`, `/random` aberto.
3. **Validação direcionada**

   * Você aplica regras específicas por path:

     * tamanho máximo,
     * schema esperado,
     * tipos de arquivo permitidos,
     * rate limit específico.
4. **Isolamento lógico**

   * Exemplo:

     * Parceiro X só pode usar `/ingest/parceiro-x/*`.
     * Interno Y só pode usar `/ingest/interno-y/*`.

No lab:

* Você configura Traefik/Nginx para aceitar só os paths definidos como “rotas oficiais” de ingestão.

---

## 2.1.4 Restrições de método HTTP

Aqui você garante que cada endpoint aceita **só o que faz sentido**:

* Exemplo:

  * `/ingest/transacoes` → só `POST`.
  * Nunca aceitar `GET`, `PUT`, `DELETE` ali.

Por quê?

* Evita uso indevido da API,
* reduz vetores de ataque,
* simplifica a lógica de validação,
* impede tentativa de leitura de dados sensíveis via métodos não previstos.

No lab:

* Configurar explicitamente `limit_except` (Nginx) / `methods` (Traefik) / regras de rota no gateway.

---

## 2.1.5 Segurança via headers (security headers & contrato)

* Quando alguém chama `POST /ingest/...`, não vem só o corpo (JSON/CSV/etc).
* Vem também um conjunto de **headers HTTP**, que são pares `Nome: Valor`.
* A Z1 (gateway) usa esses headers para:

  1. Proteger o canal e o cliente.
  2. Entender **quem** está falando.
  3. Entender **o que** está sendo enviado.
  4. Aplicar regras de segurança, rota, limite, auditoria.

---

### 2.1.5.1 Security headers (lado resposta / navegador)

Esses são mais usados quando existe navegador/UI, mas vale entender porque aparecem nos exemplos.

**O que são:**
Headers que o servidor (gateway) manda na *resposta* dizendo ao browser como se comportar.

**Exemplos úteis:**

* `Strict-Transport-Security` (HSTS)
  Instrui o navegador a **acessar sempre via HTTPS** o domínio (e, opcionalmente, seus subdomínios) por um período definido (`max-age`), ignorando tentativas de uso de HTTP. Pode incluir:

  * `max-age`: tempo em segundos em que a política será aplicada.
  * `includeSubDomains`: aplica também a todos os subdomínios.
  * `preload`: permite inclusão em listas de HSTS embutidas nos navegadores (protege mesmo no primeiro acesso).
    → Mitiga:

    * **Downgrade para HTTP** (ex.: ataques de SSL stripping), forçando canal criptografado.
    * **Ataques de rede oportunistas** (sniffing, manipulação de tráfego) em redes inseguras.
    * Redução do risco de roubo de cookies e credenciais enviados sem criptografia.

* `X-Content-Type-Options: nosniff`
  Instrui o navegador a **não fazer MIME sniffing** e a confiar estritamente no `Content-Type` enviado pelo servidor.
  
  → Mitiga: cenários em que conteúdo potencialmente malicioso (ex.: arquivos servidos como `text/plain`, mas com código) é interpretado como script, reduzindo riscos de **XSS** e execução indevida em fluxos de upload/download.

* `X-Frame-Options`
  Define **se** a aplicação pode ser carregada dentro de `<iframe>` e em quais contextos.

  * `DENY`: bloqueia qualquer uso em `<iframe>`.
  * `SAMEORIGIN`: permite apenas se o `iframe` estiver no **mesmo domínio**.
   → Mitiga:
    * **Clickjacking**: impede que a aplicação seja embutida em páginas de terceiros que tentem sobrepor elementos visuais (ex.: botão de transferência, aceite de contrato) para induzir o usuário a clicar em algo sensível sem perceber.
    * Reduz cenários onde a interface legítima é usada como componente invisível em ataques de engenharia social.

* `Content-Security-Policy` (CSP)
  Define uma **política de segurança para carregamento e execução de conteúdo** no navegador, especificando **quais origens são confiáveis** para scripts, estilos, iframes, imagens, fontes, conexões, etc.
  Exemplos relevantes:

  * `default-src 'self'`: restringe recursos, por padrão, ao mesmo domínio.
  * `script-src 'self' https://cdn-confiavel.com`: permite scripts apenas de fontes específicas.
  * `style-src 'self'`: controla estilos permitidos.
  * `frame-ancestors 'self'`: define quem pode embutir a aplicação em `<iframe>` (substituto moderno ao `X-Frame-Options`).
    → Mitiga:

    * **XSS**: mesmo que haja injeção de HTML/JS, o navegador bloqueia scripts de fontes não autorizadas ou inline (quando proibidos na política).
    * **Abusos de iframes**: com `frame-ancestors`, controla explicitamente quem pode carregar a aplicação, fortalecendo proteção contra **clickjacking**.
    * **Uso indevido de recursos externos**: impede que a página carregue scripts, imagens ou iframes de domínios maliciosos, reduzindo a superfície de ataque e o impacto de comprometimentos parciais.

**No Lab / APIs puras:**

* Mesmo que você não tenha página web sofisticada, configurar alguns desses no reverse proxy é uma boa prática.
* Em ambiente só-API, o impacto é menor, mas a mentalidade é:

  * o **gateway também protege clientes web**, se existirem.

---

### 2.1.5.2 Headers de identidade e origem (contrato com o produtor)

Esses são mais relevantes em Z1.

**Objetivo:**
Permitir que a Z1 saiba **quem está mandando dados** e **com qual papel**.

**Exemplos:**

* `Authorization: Bearer <token>`
  Token JWT/OAuth2 emitido pelo IdP.
  → Usado para autenticar o chamador (app, sistema, parceiro).

* `X-Client-Id: parceiro-x` / `X-Source-System: core-transacoes`
  Identificam **explicitamente** o sistema produtor.
  → A Z1 pode usar isso para:

  * aplicar regras específicas por fonte,
  * escolher o destino correto,
  * logar “este lote veio de X”.

**Como o gateway usa isso:**

* Valida o token (`Authorization`) com o IdP.
* Confere se o `X-Source-System` bate com a identidade autenticada.
* Se não bater → rejeita.
* Usa essas infos para:

  * rate limiting por cliente,
  * auditoria (“parceiro X mandou 10k registros às 10:32”),
  * roteamento (ex.: `/ingest/parceiro-x` só aceita `X-Client-Id: parceiro-x`).

**No Lab:**

* Você pode simular:

  * rotas que exigem header `X-Source-System`,
  * tokens/segredos guardados no Vault,
  * checagem simples desses headers no FastAPI/Nginx/Traefik.

---

### 2.1.5.3 Headers de conteúdo (Content-Type, etc.)

Aqui entra a parte de **validar o que está vindo**.

**Principais:**

* `Content-Type`
  Define o **tipo de mídia** do corpo da requisição ou resposta, informando ao cliente/servidor como interpretar o conteúdo. Exemplos:

  * `application/json` → corpo em JSON
  * `text/csv` → arquivo CSV
  * `multipart/form-data` → upload de arquivos / formulários
    → Mitiga:

    * interpretação incorreta de conteúdo (ex.: tratar dado como texto quando é binário, ou vice-versa);
    * reduz riscos de **XSS** e execução indevida de conteúdo quando combinado com `X-Content-Type-Options: nosniff`, pois evita que o navegador “chute” o tipo e execute algo que não deveria.

* `Content-Length`
  Informa o **tamanho exato do corpo** (em bytes) da requisição ou resposta, permitindo que o destinatário saiba **onde o corpo termina**.
  → Mitiga:

  * ajuda a validar requisições/respostas e detectar truncamentos ou manipulação de tráfego;
  * suporta aplicação de limites de tamanho (rate limiting / limites de payload) para reduzir riscos de **DoS por payload excessivo**;
  * quando bem tratado em conjunto com outros cabeçalhos, reduz exposição a falhas de parsing que podem ser exploradas em **HTTP Request Smuggling** e comportamentos ambíguos entre proxies/aplicações.

**Como o gateway usa isso:**

* Se o endpoint `/ingest/transacoes` espera JSON:

  * rejeita se `Content-Type` ≠ `application/json`.
* Se `Content-Length` > limite definido:

  * corta antes de bater no backend.

Isso é muito importante para:

* evitar upload de tipos proibidos (ex.: `.exe`, `.zip` inesperado),
* aplicar validações diferentes por tipo (ex.: AV/CDR só em uploads de arquivos),
* reduzir risco de DoS e parsing inconsistente.

**No Lab:**

* Configurar proxy/backend para:

  * aceitar só tipos específicos,
  * retornar erro se o `Content-Type` estiver errado.

---

### 2.1.5.4 Headers para autorização contextual (escopos, tenants, etc.)

Além de “quem é você” (JWT/Client-Id), você pode ter headers que representam:

* **Escopo de permissão**
  Ex.: token com claim “pode escrever só no dataset X”.
* **Tenant / Domínio lógico**
  Ex.: `X-Tenant-Id: banco-digital-1`.

**Como isso ajuda:**

* O gateway ou serviço de ingestão pode:

  * checar se aquele token realmente permite escrever naquele path,
  * isolar multi-tenant (dados de um cliente B2B não misturam com outro).

No Lab:

* Você pode simular isso usando claims do JWT ou headers fixos pra cada “fonte” configurada.

---

### 2.1.5.5 Headers para correlação & auditoria

Por fim, alguns headers ajudam só a **ligar os pontos**:

* `X-Request-Id`
* `X-Correlation-Id`

**Pra que servem:**

* O gateway gera um ID único por requisição.
* Esse ID é propagado para logs, serviços internos, ETL.
* Quando algo dá errado ou é suspeito:

  * você acha toda a trilha por esse ID (desde Z1 até Z2/Z4).

No Lab:

* Dá pra adicionar isso no Traefik/Nginx e logar junto — ótimo pra aprender.

---

### Resumindo 2.1.5 em uma frase “segura”

> Os headers são metadados que a Z1 usa para reforçar segurança e contrato:
>
> * alguns protegem canal e navegador (security headers);
> * outros identificam a fonte e o sistema (Auth, X-Source-System);
> * outros definem o tipo de conteúdo (Content-Type, Content-Length);
> * outros dão contexto de permissão e correlação (escopos, tenant, X-Request-Id).
>
> O Ingestion Gateway lê, valida e injeta esses headers para garantir que cada requisição seja **autenticada, autorizada, compatível com o contrato de dados e totalmente rastreável** antes de seguir para o pipeline.

#### 2.1.6 Load Balancer e variações de mercado (quando aplicável)

Dependendo do ambiente:

* Um **Load Balancer L4/L7** pode ficar na frente do gateway:

  * distribuindo tráfego entre múltiplas instâncias de Traefik/Nginx/Kong etc.
  * Ex.: AWS ALB/NLB, Azure App GW, GCP LB.
* Em cenários enterprise:

  * soluções como F5, NGINX Plus, Apigee, Kong, Istio/Envoy podem assumir papéis combinados de LB + API Gateway + políticas.

Mas o princípio **não muda**:

> Independentemente da ferramenta, a função da Z1 é manter **uma borda única, autenticada, validada, auditada e com rotas explícitas**.
> O resto do ecossistema nunca é exposto diretamente.
