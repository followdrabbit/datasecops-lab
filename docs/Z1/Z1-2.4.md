# 2.4 Content Validation (Validação de Conteúdo)

Depois que a requisição:

1. passou pelo **WAF** (bloqueamos ataques óbvios),
2. foi **autenticada e autorizada** na borda (sabemos “quem é” e “o que pode fazer”),

entra a **Content Validation**:

> É a checagem se o **conteúdo enviado** realmente bate com o **contrato esperado** para aquele endpoint/fonte.

Ela responde à pergunta:

> “Esse dado tem a forma mínima aceitável para entrar na nossa plataforma sem virar lixo, vulnerabilidade ou veneno para modelos?”

Não é antivírus (isso é o 2.5).
Não é WAF genérico.
É **validação específica de dados** para o seu domínio / endpoint.

---

## 2.4.1 O que a Content Validation faz (em termos simples)

Para cada endpoint/tipo de ingestão, a Z1 valida:

1. **Tipo de conteúdo (MIME / Content-Type)**

   * Ex.: `/ingest/transacoes` só aceita `application/json`.
   * `/ingest/csv` só aceita `text/csv`.
   * `/ingest/docs` só aceita `application/pdf` (se previsto).

2. **Tamanho (Content-Length / limites internos)**

   * Limites máximos por requisição e por arquivo.
   * Protege contra DoS e payloads exagerados.

3. **Estrutura básica (schema inicial)**

   * Campos obrigatórios presentes?
   * Tipos corretos? (`id` numérico, `timestamp` válido, etc.)
   * Formato esperado? (ex.: ISO 8601 para datas)

4. **Regras de consistência simples**

   * Não aceitar:

     * valores totalmente fora do contexto esperado,
     * chaves desconhecidas (quando você quer contrato estrito),
     * registros vazios ou obviamente quebrados.

5. **Aderência ao “data contract” definido na Z0**

   * Cada fonte Z0 oficial tem um contrato.
   * A Content Validation é o enforcement inicial desse contrato.

Se falhar, a requisição é **rejeitada na Z1**, logada, e não segue para Z2.

---

## 2.4.2 Exemplos concretos (pra fixar)

### Exemplo 1 — Ingestão de transações

Endpoint: `/ingest/transacoes`

Contrato mínimo (simplificado):

```json
{
  "id_transacao": "string não vazia",
  "valor": "número > 0",
  "data_hora": "ISO 8601",
  "canal": "enum: [APP, WEB, ATM]",
  "id_cliente": "string não vazia"
}
```

Content Validation faz:

* Rejeita se:

  * `Content-Type` não for `application/json`.
  * `valor` não for número ou for ≤ 0.
  * `data_hora` não for data válida.
  * `canal` tiver valor fora da lista.
  * faltarem campos obrigatórios.
* Opcional:

  * limita tamanho (`N` transações por request, não 5 milhões de uma vez).

Isso evita:

* lixo estrutural,
* erros de parse,
* dados sem mínimo de integridade entrando no Raw.

---

### Exemplo 2 — Upload de CSV

Endpoint: `/ingest/arquivo-csv`

Contrato mínimo:

* `Content-Type: text/csv`
* Primeira linha = cabeçalho fixo: `id;data;valor`
* Separador `;`
* Máximo 10 MB.

Content Validation faz:

* Confere tipo.
* Lê cabeçalho — se não bater, rejeita.
* Conta colunas — se linha tiver colunas a mais/menos, rejeita.
* Limita tamanho e número de linhas.

---

### Exemplo 3 — Upload de documento

Endpoint: `/ingest/docs`

* Aceita só `application/pdf` ou `image/jpeg` (por exemplo).
* Tamanho limite.
* Passa antes por AV/CDR (2.5).

Content Validation:

* Garante que alguém não manda `.exe` renomeado,
* ou `application/octet-stream` genérico,
* ou um ZIP onde não deveria existir.

---

## 2.4.3 Diferença para WAF, AV/CDR e validação “lá na frente”

Pra não confundir:

* **WAF**:

  * olha padrão de ataque genérico (injeção, XSS, etc.).
  * não conhece seu domínio de negócio.
* **Content Validation (Z1)**:

  * conhece o contrato do endpoint.
  * garante que a entrada tem a forma/estrutura esperada.
* **Anti-malware / CDR (2.5)**:

  * garante que o arquivo não é malicioso.
* **Validações mais profundas (Z2–Z4)**:

  * verificam consistência estatística, qualidade avançada, outliers, etc.

Aqui na Z1 a regra é:

> Rejeitar o que é claramente inválido, perigoso ou fora de contrato **antes** de sujar o Raw Data Lake.

---

## 2.4.4 Como a Content Validation conversa com Z0

Lembra da Z0:

* cada fonte oficial documentada tem:

  * dono,
  * formato,
  * campos,
  * sensibilidade.

A Content Validation em Z1 é exatamente o mecanismo que diz:

> “Só vou aceitar dados dessa fonte se vierem no formato que combinamos.”

Isso:

* força disciplina,
* reduz risco de data poisoning acidental,
* impede “qualquer CSV aleatório” de cair no lago bruto.

---

## 2.4.5 Implementação prática no Lab

No **MLOps Security Lab**, você pode mostrar Content Validation com coisas simples e didáticas:

* **No reverse proxy/API Gateway**:

  * bloquear content-types não permitidos,
  * limitar tamanho do corpo,
  * aceitar só certos paths/métodos.

* **No serviço de ingestão (ex.: FastAPI)**:

  * usar modelos (Pydantic) para validar JSON.
  * retornar `400 Bad Request` com erro se o payload não bater.
  * validar campos obrigatórios e tipos.

* **No Airflow ou scripts de ETL**:

  * tarefas de validação:

    * checar header de CSV,
    * contar colunas,
    * verificar tipos básicos,
    * descartar ou enviar para “quarentena” o que falhar.

A ideia não é virar Great Expectations full neste lab (pode ser um passo futuro), mas:

> mostrar que **ingestão segura e madura** sempre inclui validação explícita de conteúdo, não apenas “deixa o parser tentar”.

---

## 2.4.6 Boas práticas para Content Validation

* **Fail fast**:

  * rejeite cedo o que está errado,
  * não empurre dado duvidoso pra frente.
* **Mensagens de erro claras (mas não verbosas demais)**:

  * boas pra produtor corrigir,
  * sem vazar detalhes internos (nome de tabela, stacktrace).
* **Logar o motivo da rejeição**:

  * para análise, tuning e detecção de abuso.
* **Contratos versionados**:

  * quando o esquema mudar, versionar o endpoint ou o contrato.
* **Não logar payload sensível completo**:

  * principalmente em erros,
  * guarde só o suficiente para suporte/investigação.
