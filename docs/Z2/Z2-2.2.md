# 2.2 Criptografia em Repouso & KMS (Chaves Gerenciadas com Governança)

A Raw Zone da Z2 é onde vivem os **dados brutos mais sensíveis** (PII, logs de transação, eventos de risco, dados de clientes e parceiros).
Se alguém tiver acesso físico ao disco, backup, snapshot ou dump de volume, nada disso pode estar em texto puro.

Por isso, o princípio aqui é:

> **100% dos dados em Z2 em repouso são criptografados com chaves gerenciadas (KMS/Vault), com política, rotação e auditoria.**

Não é “liguei o checkbox de encryption e esqueci”. É parte da arquitetura de segurança.

---

## 2.2.1 O que é Criptografia em Repouso na Z2

Criptografia em repouso = todos os objetos/arquivos/blocos armazenados na Raw Zone estão protegidos por chaves criptográficas.
Mesmo que alguém copie o disco, o snapshot ou o arquivo bruto:

* sem acesso às chaves,
* o conteúdo é inutilizável.

No contexto da Z2 (MinIO/S3-like):

* Cada objeto é criptografado no servidor ou no cliente.
* A chave usada para criptografar os dados (**Data Key**) é protegida por uma chave mestra (**Master Key**) mantida em um **KMS/HSM/Vault**.

---

## 2.2.2 KMS / HSM / Vault — papéis e opções

**KMS (Key Management Service)** é o componente responsável por:

* gerar, armazenar e proteger as **chaves-mestras**,
* expor operações controladas de `encrypt/decrypt` de data keys,
* registrar logs de uso de chaves,
* aplicar políticas (quem pode usar qual chave, para quê).

Exemplos (mundo real):

* AWS KMS, Azure Key Vault, GCP KMS, HashiCorp Vault (Transit), HSMs dedicados.

No **MLOps Security Lab**:

* Usamos (ou simulamos) o papel de KMS via **HashiCorp Vault**:

  * engine **Transit** para criptografia como serviço,
  * policies por serviço,
  * chaves não ficam dentro do código nem do container.

---

## 2.2.3 Padrão de projeto: Envelope Encryption

Para Z2, o padrão recomendado é **envelope encryption**:

1. O KMS (ex.: Vault Transit) mantém uma **Key Encryption Key (KEK)** segura.
2. Quando um conector oficial (Airflow, serviço de ingestão) precisa gravar dado em Z2:

   * pede ao KMS uma **data key** (chave simétrica temporária).
3. Os dados do arquivo são criptografados com a data key (ex.: AES-256-GCM).
4. A data key é criptografada pela KEK e armazenada junto com o objeto (metadado).
5. Para leitura:

   * o serviço autorizado pega a data key criptografada,
   * pede ao KMS a decriptação,
   * decripta o conteúdo.

Benefícios:

* As chaves-mestras nunca saem do KMS.
* Você pode rotacionar a KEK sem recriptografar tudo de uma vez (KMS cuida disso).
* Permite políticas finas: quem pode usar qual chave para ler/decriptar qual conjunto de dados.

---

## 2.2.4 Políticas de chaves (Key Management & Governança)

Criptografia forte sem governança é “segurança cosplay”. Então:

1. **Chaves por domínio/sensibilidade**

   * Ex.:

     * `kms-key/raw-core-banking`,
     * `kms-key/raw-fraude`,
     * `kms-key/raw-logs`.
   * Evita que uma única chave exposta comprometa tudo.

2. **Rotação periódica**

   * Rotacionar KEKs em ciclos definidos (ex.: 6–12 meses ou conforme política interna).
   * KMS deve suportar rotação com registro de versões.

3. **Políticas de uso**

   * Apenas service accounts específicas podem usar cada chave.
   * Ex.:

     * `svc-airflow-ingest-core` → pode usar `kms-key/raw-core-banking` para encrypt/decrypt.
     * `svc-ds-fraude` → pode apenas `decrypt` em certos caminhos.
   * Nunca dar permissão de `kms:Decrypt` global pra usuário humano genérico.

4. **Auditoria de uso de chaves**

   * Toda chamada de `Encrypt/Decrypt` logada:

     * quem,
     * quando,
     * para qual chave,
     * com qual contexto.
   * Logs enviados para Z9 (SIEM) para detectar:

     * uso anômalo de chaves,
     * possíveis exfiltrações.

---

## 2.2.5 Enforcement técnico (como garantir que ninguém burla)

Z2 deve **forçar** o uso correto de criptografia e de KMS:

* Buckets/volumes configurados para:

  * exigir criptografia (SSE-KMS / SSE-C / KES no caso do MinIO),
  * rejeitar `PUT` sem criptografia ou fora do padrão.
* Infra como código (Terraform, Helm etc.):

  * define:

    * quais chaves usar,
    * quais policies, roles, endpoints.
* Rede:

  * KMS/Vault acessível apenas a componentes autorizados (Z1/Z2/Z4/Z5/Z8),
  * sempre via TLS + Auth forte.

Resultado prático:

> Não existe “upload cru” para Z2.
> Ou você fala com o gateway + conectores oficiais, que usam KMS e políticas corretas, ou o write é negado.

---

## 2.2.6 Erros clássicos para evitar

Pontos que você pode citar na entrevista como anti-patterns:

* Guardar chave AES fixa em variável de ambiente ou no código.
* Usar `SSE-S3`/criptografia “gerenciada pelo provedor” sem controle de chaves em cenário regulado sensível.
* Dar acesso de administrador de KMS para qualquer SRE/dev “porque é mais fácil”.
* Não logar operações de chave (fica cego pra abuso).
* Mesma chave para tudo (um vazamento = todo o data lake exposto).

---

## 2.2.7 Relação com frameworks e justificativa de negócio

**Por que isso é importante (além de ser bonito no diagrama):**

* **NIST SP 800-53**

  * SC-12 / SC-13: proteção e gerenciamento de chaves.
  * SC-28: proteção da confidencialidade em repouso.
  * AU-2 / AU-6: trilhas de auditoria sobre uso de chaves e dados.
* **CSA CCM**

  * DSI-01/02 (Data at Rest Encryption),
  * IAM, LOG, CRY.
* **LGPD / GDPR / Reguladores financeiros**

  * Requisito de “medidas técnicas e administrativas” para proteger dados sensíveis.
  * Facilita demonstração de diligência em caso de incidente.
* **MLOps/AI**

  * Modelos treinados em cima de dados criptograficamente protegidos e rastreáveis → argumento forte de governança e confiança.
