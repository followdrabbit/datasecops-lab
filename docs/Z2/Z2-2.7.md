# 2.7 Áreas de Staging, Quarentena & Reprocessamento

*(onde o lixo fica contido e o que é bom ganha segunda chance)*

Antes de qualquer coisa cair na **Raw Zone oficial**, a arquitetura precisa de “áreas tampão” para isolar o que ainda é duvidoso, permitir reprocesso controlado e evitar que lixo ou artefatos suspeitos contaminem a sua base de verdade.

Princípio central:

> **Staging e Quarentena são zonas de contenção. Z2 (Raw) só recebe o que foi aprovado.
> Reprocessamento acontece sempre a partir dessas zonas ou da própria Raw, nunca direto da borda.**

---

## 2.7.1 Staging: a antessala da Raw

**O que é**

* Uma **área temporária e restrita** onde os dados que passaram pela Z1, mas ainda não foram totalmente consolidados, são colocados antes de irem para a Raw Zone definitiva.
* Fica tecnicamente próxima ou dentro da mesma infraestrutura de storage, mas com **políticas diferentes**.

**Objetivo**

* Desacoplar o tempo de chegada (ingestão) do tempo de gravação final em Raw.
* Permitir:

  * reordenar,
  * normalizar o formato (sem perder semântica),
  * dividir em partições,
  * aplicar checagens adicionais (ex.: contagem de registros, consistência básica).

**Regras típicas**

* Escrita em Staging:

  * apenas pelos **conectores oficiais da Z1**.
* Leitura:

  * apenas por jobs de ETL/curadoria responsáveis por promover dados para Raw.
* Dados têm:

  * **TTL definido** (ex.: 24–72h),
  * uso exclusivo para processamento intermediário.
* Nada em Staging é fonte de verdade para modelos/relatórios.

**Exemplo prático (lab)**

* Upload chega em `/ingest/transacoes`.
* Após validação + AV + higiene:

  * é salvo em `staging/transacoes/incoming/2025-11-10/req-abc123.json`.
* Um DAG do Airflow:

  * lê esse arquivo,
  * valida contagem, schema, metadados,
  * escreve em `raw/core-transacoes/transacoes/year=2025/.../part-0001.parquet`,
  * marca o objeto de staging como processado ou o remove após retenção.

---

## 2.7.2 Quarentena: isolamento de conteúdo suspeito

**O que é**

* Uma área **hiper-restrita e auditada** para armazenar:

  * arquivos/dados reprovados em alguma checagem,
  * payloads marcados como suspeitos (ex.: malware detectado, schema inválido, anomalia grave),
  * amostras para investigação de incidentes ou ajuste de regras.

**Por que existe**

* Você não quer:

  * perder evidência (pra entender o ataque/falha),
  * nem deixar o arquivo suspeito circular no ambiente normal.
* A Quarentena permite:

  * preservar a evidência,
  * sem risco de contaminação dos pipelines de produção/ML.

**Regras fortes (importantes pra entrevista)**

* Escrita:

  * apenas pelos componentes de Z1/Z2 que fazem validação/scan (ex.: `scan-service`, `ingest-service`, DAG de validação).
* Leitura:

  * apenas por:

    * time de segurança,
    * time de plataforma,
    * roles específicas (ex.: `forensics_read`),
    * sempre auditado (log detalhado).
* Dados em Quarentena:

  * **não** são usados em treino nem em relatórios,
  * se precisarem ser reaproveitados:

    * só após análise/manual ou pipeline de “descontaminação”,
    * com promoção explícita (ex.: mover para Staging/Raw com novo metadado, registrando a decisão).

**Exemplos de envio para Quarentena**

* Arquivo PDF com malware detectado pelo Anti-malware.
* Lote CSV com 90% dos registros com schema inválido (pode indicar bug/ataque).
* Payload com PII em endpoint que não deveria recebê-la (violação de contrato).

---

## 2.7.3 Reprocessamento: corrigir sem corromper a verdade

**O que é**

Conjunto de **pipelines controlados** que:

* reprocessam dados já presentes em Staging, Quarentena ou Raw,
* para:

  * corrigir erros de parsing,
  * aplicar novo schema,
  * reexecutar lógica de curadoria,
  * regenerar features,
  * ou ajustar dados após correção de um bug no pipeline.

**Princípios**

1. **Idempotência & rastreabilidade**

   * Cada execução de reprocessamento:

     * gera novos artefatos (novas versões em Raw/Z3),
     * não sobrescreve silenciosamente o histórico.
   * Metadados indicam:

     * qual job rodou,
     * qual versão do código,
     * qual input foi usado.

2. **Origem clara**

   * Se reprocessar a partir de Staging:

     * registrar que a nova versão foi derivada daquela entrada.
   * Se reprocessar a partir da própria Raw (ex.: novo parser):

     * referenciar as versões originais via hashes/versionId.

3. **Política de promoção**

   * Só promover para Raw/Curated após:

     * passar novamente pelos controles (schema, qualidade, etc.),
     * registrar metadados de “reprocessed_from”.

**Exemplo prático (lab)**

* Descobre-se que um DAG de ingestão de transações trocou `debito`/`credito` por 2 dias.
* Essas partições em Raw são marcadas como `invalid=true`.
* Um DAG de reprocesso:

  * lê o Raw original (versões corretas ou arquivos de Staging guardados),
  * corrige os valores,
  * grava novas versões com `correction_job_id=X`,
  * marca as versões antigas como `superseded`, mas **não as apaga** (graças ao versionamento/WORM).

---

## 2.7.4 Integração com os demais controles da Z2

Staging, Quarentena e Reprocessamento não são ilhas; eles reforçam o que você já definiu em 2.1–2.6:

* **Com 2.1 Raw Zone**

  * Garantem que só dado aprovado chegue na Raw oficial.
* **Com 2.2 Criptografia & KMS**

  * Tudo em Staging/Quarentena também deve ser criptografado (não é “lugar relaxado”).
* **Com 2.3 Network Isolation**

  * Staging/Quarentena não têm acesso externo.
* **Com 2.4 IAM / ABAC**

  * Perfis ainda mais restritos para Quarentena.
* **Com 2.5 Versionamento**

  * Reprocessos geram novas versões; nada se perde.
* **Com 2.6 Metadados & Integridade**

  * Staging/Quarentena também registram origem, motivo (ex.: `reason=malware_detected`, `reason=schema_violation`),
  * Reprocessos registram `reprocess_reason`, `source_version`, etc.

---

## 2.7.5 Riscos mitigados (link com seção 3 de Z2)

Staging + Quarentena + Reprocessamento ajudam diretamente a mitigar:

* **3.1 — Vazamento de dados brutos**

  * Quarentena restrita impede que payload suspeito ou sensível demais “escorra” pro resto da org.
* **3.2 — Alteração não autorizada**

  * Reprocesso controlado + versionamento evitam “ajustes manuais” invisíveis.
* **3.3 — Exclusão / perda**

  * Staging com política clara + promoção controlada reduz risco de perder dados na transição.
* **3.5 — Shadow pipelines**

  * Com fluxos padronizados Staging → Raw → Curated, qualquer caminho fora disso fica evidente.
* **3.6 / 3.7 — Falta de proveniência & treino em dados errados**

  * Metadados de origem/motivo/reprocesso garantem que você sabe exatamente o que foi usado em cada etapa.

---

## 2.7.6 Como implementar no MLOps Security Lab (prático)

No lab, dá pra ilustrar assim:

* **Buckets separados**:

  * `staging/` — dados recém chegados, TTL curto.
  * `raw/` — dados aprovados, versionados.
  * `quarantine/` — acesso só por `svc-security` / `svc-forensics`.
* **DAGs no Airflow**:

  * `ingest_*`:

    * leem da Z1,
    * escrevem em `staging/`.
  * `promote_to_raw_*`:

    * validam os dados em `staging/`,
    * calculam hash,
    * escrevem em `raw/`.
  * `reprocess_*`:

    * leem de `raw/` ou `staging/`,
    * geram novas versões corrigidas.
* **Policies (Vault/MinIO)**:

  * `svc-ingest` → write em `staging/...`.
  * `svc-promote` → read `staging/...`, write `raw/...`.
  * `svc-security` → read `quarantine/...`.
  * ninguém com acesso amplo aos três sem justificativa.

Mensagem pra fechar:

> “Staging e Quarentena são partes formais da arquitetura, não ‘pastinhas temporárias’.
> Elas existem para que só o que é rastreável, íntegro e aprovado se torne dado bruto oficial em Z2 — e para que todo desvio tenha um lugar seguro pra ser analisado, sem contaminar o restante do ambiente.”
