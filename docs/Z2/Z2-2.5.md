# 2.5 Versionamento & Imutabilidade (Nunca perder, nunca sobrescrever no escuro)

Se a Z2 é o **repositório de verdade histórica**, então:

> **Nada pode ser “sumir” ou ser sobrescrito silenciosamente.**
> Você precisa saber *o que entrou, quando entrou, como entrou* — e conseguir voltar no tempo.

Por isso, dois pilares:

1. **Versionamento** — guardar todas as versões de um objeto/lote.
2. **Imutabilidade (WORM)** — impedir alteração/remoção indevida por um período definido.

Esses mecanismos são fundamentais em ambientes regulados, de auditoria forte e MLOps sério.

---

## 2.5.1 Versionamento: linha do tempo do dado bruto

**O que é:**

* Ao habilitar **versioning** no bucket/volume da Raw Zone:

  * toda vez que um objeto é sobrescrito ou deletado,
  * o sistema mantém as versões anteriores,
  * cada versão tem um `versionId` único.

**Por que isso importa na Z2:**

* **Reprodutibilidade de modelos**

  * Permite saber exatamente quais arquivos/datasets alimentaram um treino de modelo em uma data específica.
* **Proteção contra erro humano**

  * Se alguém sobrescreve ou remove um arquivo por engano, você consegue restaurar a versão anterior.
* **Forense e auditoria**

  * Consegue provar que em `2025-08-10` existia o arquivo X com hash Y, usado no modelo Z.

**Boas práticas:**

* Habilitar versionamento **por padrão** em todos os buckets de `raw/`.
* Monitorar:

  * deletes,
  * overwrites,
  * tamanhos de bucket (para planejar custos/limpeza com retenção controlada).

---

## 2.5.2 Imutabilidade / WORM: blindagem contra alteração e delete

Versionamento ajuda a recuperar, mas **não impede** que alguém mal-intencionado ou um script bugado apague/alterne tudo.

Aí entra o segundo nível:

> **WORM (Write Once, Read Many)** — uma vez escrito, não pode ser modificado ou apagado até o fim de um período de retenção.

**Como funciona (conceito):**

* Ao ativar um modo de **Object Lock / Immutability**:

  * cada objeto ou bucket recebe uma política de retenção (ex.: 1 ano, 5 anos),
  * tentativas de `overwrite` ou `delete` antes do prazo são bloqueadas pelo próprio storage.
* Alguns providers suportam:

  * modo **governance** (apenas roles muito específicas conseguem alterar),
  * modo **compliance** (nem o admin consegue apagar antes do prazo).

**Por que usar na Z2:**

* Protege:

  * evidências de auditoria,
  * logs brutos,
  * trilhas de decisão de modelos de crédito/fraude,
  * dados regulatórios que precisam ser mantidos por N anos.
* Mitiga:

  * **apagamentos maliciosos** (ransomware interno, sabotagem),
  * **“corrigir” o passado** pra esconder erro/fraude.

**Referências de mercado:**

* WORM / Immutability é prática padrão em setores regulados (financeiro, mercado de capitais, saúde).
* Alinhado com:

  * NIST SP 800-53 Rev.5 — **AU-9 (Proteção de registros de auditoria)**, **SI-7 (Integridade)**, **CP/MP** para preservação de evidências.

---

## 2.5.3 Como aplicar na prática (Z2 / Lab)

No **MLOps Security Lab**, você pode materializar assim:

1. **MinIO com Versioning**

   * Ativar versionamento no bucket `raw/`.
   * Exemplo:

     * `mc version enable minio/raw`
   * Mostrar no doc:

     * upload de `data.parquet`,
     * overwrite,
     * listar versões,
     * restaurar versão antiga.

2. **Simular Imutabilidade / WORM**

   * Usar recursos de **Object Lock** (se disponíveis) ou simular via:

     * políticas que:

       * proíbem `DeleteObject` em `raw/` em produção,
       * só permitem exclusão via processo controlado (ex.: job de expurgo com aprovação).
   * Documentar como seria num cloud real:

     * S3 Object Lock, Azure Blob Immutability, etc.

3. **Integração com IAM & Logs**

   * Toda tentativa de `delete`/`overwrite`:

     * logada,
     * enviada pro Z9 (SIEM),
     * correlacionada à identidade (2.4) e origem (2.3).

Mensagem que você quer deixar clara:

> “Em Z2, o default não é sobrescrever, é **preservar**.
> Se alguém mexe num dado bruto, eu sei quem foi, quando foi — e ainda tenho a versão anterior.”

---

## 2.5.4 Riscos mitigados (pra linkar com a seção 3)

Versionamento + Imutabilidade endereçam diretamente:

* **3.2 — Alteração não autorizada**

  * Dificulta ou impede que alguém manipule histórico sem deixar rastro.
* **3.3 — Exclusão acidental ou maliciosa**

  * Mesmo se alguém tentar apagar, o dado está protegido por WORM/versioning.
* **3.6 — Falta de evidência para auditoria e explicabilidade**

  * Garante que você consegue “voltar no tempo” para provar de onde veio o dado de treino/decisão.
